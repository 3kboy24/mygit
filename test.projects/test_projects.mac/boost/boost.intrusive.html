<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Chapter 18. Boost.Intrusive</title><link rel="stylesheet" type="text/css" href="/static/main/css/main.css"><link rel="home" href="the-boost-c++-libraries" title="The Boost C++ Libraries"><link rel="prev" href="boost.heap" title="Chapter 17. Boost.Heap"><link rel="next" href="boost.multiarray" title="Chapter 19. Boost.MultiArray"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.11.0/styles/vs.min.css"><script onload="hljs.initHighlightingOnLoad()" src="//cdn.jsdelivr.net/highlight.js/9.11.0/highlight.min.js"></script><script>var disqus_identifier = 'boost.intrusive';</script><script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-59953346-1', 'auto');
      ga('send', 'pageview');
    </script><script async="async" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-54ede4aa2dd8667c"></script></head><body class="chapter"><div class="relative"><header><a href="the-boost-c++-libraries"><img src="/static/main/img/boost-logo.svg" alt="" width="20" height="20" id="boost-logo">The Boost C++ Libraries</a><a href="https://twitter.com/theboostcpplibs" class="twitter"><img src="/static/main/img/twitter.png" width="17" height="14" alt="Follow @theboostcpplibs" class="twitter"></a></header><nav><ul><li><a href="the-boost-c++-libraries">The Boost C++ Libraries</a><ul><li><a href="containers">Part III. Containers</a><ul><li><a href="boost.multiindex">Chapter 12. Boost.MultiIndex</a></li><li><a href="boost.bimap">Chapter 13. Boost.Bimap</a></li><li><a href="boost.array">Chapter 14. Boost.Array</a></li><li><a href="boost.unordered">Chapter 15. Boost.Unordered</a></li><li><a href="boost.circularbuffer">Chapter 16. Boost.CircularBuffer</a></li><li><a href="boost.heap">Chapter 17. Boost.Heap</a></li><li><strong><a href="boost.intrusive">Chapter 18. Boost.Intrusive</a></strong></li><li><a href="boost.multiarray">Chapter 19. Boost.MultiArray</a></li><li><a href="boost.container">Chapter 20. Boost.Container</a></li></ul></li></ul></li></ul>
        
<script>
  (function() {
    var cx = '011552474235077786014:zyife9oy_sk';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<div class="gcse-search"></div>
<script>
function onAdClick() {
  var ad = document.querySelector('.ad');
  ad.style.cursor = 'default';
  var img = document.querySelector('.ad .content img');
  img.style.display = 'none';
  var links = document.getElementsByClassName('shoplink');
  for (var i = 0; i < links.length; ++i) {
    links[i].style.display = 'inline';
  }
  ga('send', 'event', 'ad', 'click', 'book');
}
</script>
  <div class="ad" onclick="onAdClick()" style="cursor:pointer;width:200px;margin-top:7px">
    <div class="title">Get the book</div>
    <div class="url">theboostcpplibraries.com</div>
    <div class="content">
      <img src="/static/main/img/book-cover-small.png" alt="The Boost C++ Libraries" width="74" height="94" style="float:left;margin-right:5px"/>
      <table style="font-size:1.2em;border-collapse:collapse">
        <tr>
          <td style="text-align:right">$45.95</td>
          <td>Print</td>
          <td class="shoplink" style="display:none"><a href="https://www.amazon.com/gp/product/1937434362/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=1937434362&amp;linkCode=as2&amp;tag=theboostcppli-20&amp;linkId=ZD2OKWS6OJX5F3S3" style="text-decoration:underline" onclick="ga('send', 'event', 'ad', 'click', 'print');return true;">Amazon</a></td>
        </tr>
        <tr>
          <td style="text-align:right">$9.99</td>
          <td>Kindle</td>
          <td class="shoplink" style="display:none"><a href="https://www.amazon.com/gp/product/B00OX0KJOK/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=B00OX0KJOK&amp;linkCode=as2&amp;tag=theboostcppli-20&amp;linkId=B5LGTSOTEZ6C7EVL" style="text-decoration:underline" onclick="ga('send', 'event', 'ad', 'click', 'kindle');return true;">Amazon</a></td>
        </tr>
        <tr>
          <td style="text-align:right">$9.99</td>
          <td>E-book</td>
          <td class="shoplink" style="display:none"><a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&amp;hosted_button_id=F7WCSZLHDU9GN" style="text-decoration:underline" onclick="ga('send', 'event', 'ad', 'click', 'ebook');return true;">Download</a></td>
        </tr>
        <tr>
          <td style="text-align:right">$9.99</td>
          <td>PDF</td>
          <td class="shoplink" style="display:none"><a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&amp;hosted_button_id=HMMF8LP558LHL" style="text-decoration:underline" onclick="ga('send', 'event', 'ad', 'click', 'pdf');return true;">Download</a></td>
        </tr>
      </table>
    </div>
  </div>
  
  <a href="/expert" class="ad" style="margin-top:15px">
    <div class="title">&hellip; or the expert</div>
    <div class="url">theboostcpplibraries.com</div>
    <div class="content">
      <img src="/static/main/img/boris-schaeling-small.jpg" alt="Boris Schäling" width="74" height="74" style="float:left;margin-right:5px"/>
      <div style="font-size:1.2em;color:grey">Presentations,<br>trainings and<br>consulting on<br>Boost and C++</div>
    </div>
  </a>
  
  
  
  <div style="text-align:center;margin:15px 0px"><a href="/ad" style="color:darkgrey">Your exclusive ad here?</a></div>
  <!--script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-3679079217438126" data-ad-slot="4616164693" data-ad-format="auto"></ins>
  <script>(adsbygoogle = window.adsbygoogle || []).push({});</script-->
  

      </nav></div><div lang="en" class="chapter" id="boost.intrusive"><div class="titlepage"><div><div><h1 class="title">Chapter 18. Boost.Intrusive</h1></div></div></div><p><a class="link" href="http://www.boost.org/libs/intrusive" target="_top">Boost.Intrusive</a> is a library especially suited for use in high performance programs. The library provides tools to create <span class="concept">intrusive containers</span>. These containers replace the known containers from the standard library. Their disadvantage is that they can’t be used as easily as, for example, <code class="classname">std::list</code> or <code class="classname">std::set</code>. But they have these advantages:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Intrusive containers don’t allocate memory dynamically. A call to <code class="methodname">push_back()</code> doesn’t lead to a dynamic allocation with <code class="code">new</code>. This is a one reason why intrusive containers can improve performance.</p></li><li class="listitem"><p>Intrusive containers store the original objects, not copies. After all, they don’t allocate memory dynamically. This leads to another advantage: Member functions such as <code class="methodname">push_back()</code> don’t throw exceptions because they neither allocate memory nor copy objects.</p></li></ul></div><p>The advantages are paid for with more complicated code because preconditions must be met to store objects in intrusive containers. You cannot store objects of arbitrary types in intrusive containers. For example, you cannot put strings of type <code class="classname">std::string</code> in an intrusive container; instead you must use containers from the standard library.</p><p><a class="xref" href="boost.intrusive#ex.intrusive_01" title="Example 18.1. Using boost::intrusive::list">Example 18.1</a> prepares a class <code class="classname">animal</code> to allow objects of this type to be stored in an intrusive list.</p>
    
    <div class="example" id="ex.intrusive_01"><div class="example-title">Example 18.1. Using <code class="classname">boost::intrusive::list</code></div><div class="example-contents"><pre class="programlisting"><code class="cpp">#include &lt;boost/intrusive/list.hpp&gt;
#include &lt;string&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;

using namespace boost::intrusive;

struct animal : public list_base_hook&lt;&gt;
{
  std::string name;
  int legs;
  animal(std::string n, int l) : name{std::move(n)}, legs{l} {}
};

int main()
{
  animal a1{"cat", 4};
  animal a2{"shark", 0};
  animal a3{"spider", 8};

  typedef list&lt;animal&gt; animal_list;
  animal_list animals;

  animals.push_back(a1);
  animals.push_back(a2);
  animals.push_back(a3);

  a1.name = "dog";

  for (const animal &amp;a : animals)
    std::cout &lt;&lt; a.name &lt;&lt; '\n';
}</code></pre></div></div>
    
  <p>In a list, an element is always accessed from another element, usually using a pointer. If an intrusive list is to store objects of type <code class="classname">animal</code> without dynamic memory allocation, pointers must exist somewhere to concatenate elements.</p><p>To store objects of type <code class="classname">animal</code> in an intrusive list, the class must provide the variables required by the intrusive list to concatenate elements. Boost.Intrusive provides <span class="concept">hooks</span> – classes from which the required variables are inherited. To allow objects of the type <code class="classname">animal</code> to be stored in an intrusive list, <code class="classname">animal</code> must be derived from the class <code class="classname">boost::intrusive::list_base_hook</code>.</p><p>Hooks make it possible to ignore the implementation details. However, it’s safe to assume that <code class="classname">boost::intrusive::list_base_hook</code> provides at least two pointers because <code class="classname">boost::intrusive::list</code> is a doubly linked list. Thanks to the base class <code class="classname">boost::intrusive::list_base_hook</code>, <code class="classname">animal</code> defines these two pointers to allow objects of this type to be concatenated.</p><p>Please note that <code class="classname">boost::intrusive::list_base_hook</code> is a template that comes with default template parameters. Thus, no types need to be passed explicitly.</p><p>Boost.Intrusive provides the class <code class="classname">boost::intrusive::list</code> to create an intrusive list. This class is defined in <code class="filename">boost/intrusive/list.hpp</code> and is used like <code class="classname">std::list</code>. Elements can be added using <code class="methodname">push_back()</code>, and it’s also possible to iterate over elements.</p><p>It is important to understand that intrusive containers do not store copies; they store the original objects. <a class="xref" href="boost.intrusive#ex.intrusive_01" title="Example 18.1. Using boost::intrusive::list">Example 18.1</a> writes <code class="computeroutput">dog</code>, <code class="computeroutput">shark</code>, and <code class="computeroutput">spider</code> to standard output – not <code class="computeroutput">cat</code>. The object <var class="varname">a1</var> is linked into the list. That’s why the change of the name is visible when the program iterates over the elements in the list and displays the names.</p><p>Because intrusive containers don’t store copies, you must remove objects from intrusive containers before you destroy them.</p>
    
    <div class="example" id="ex.intrusive_02"><div class="example-title">Example 18.2. Removing and destroying dynamically allocated objects</div><div class="example-contents"><pre class="programlisting"><code class="cpp">#include &lt;boost/intrusive/list.hpp&gt;
#include &lt;string&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;

using namespace boost::intrusive;

struct animal : public list_base_hook&lt;&gt;
{
  std::string name;
  int legs;
  animal(std::string n, int l) : name{std::move(n)}, legs{l} {}
};

int main()
{
  animal a1{"cat", 4};
  animal a2{"shark", 0};
  animal *a3 = new animal{"spider", 8};

  typedef list&lt;animal&gt; animal_list;
  animal_list animals;

  animals.push_back(a1);
  animals.push_back(a2);
  animals.push_back(*a3);

  animals.pop_back();
  delete a3;

  for (const animal &amp;a : animals)
    std::cout &lt;&lt; a.name &lt;&lt; '\n';
}</code></pre></div></div>
    
  <p><a class="xref" href="boost.intrusive#ex.intrusive_02" title="Example 18.2. Removing and destroying dynamically allocated objects">Example 18.2</a> creates an object of type <code class="classname">animal</code> with <code class="code">new</code> and inserts it to the list <var class="varname">animals</var>. If you want to destroy the object with <code class="code">delete</code> when you don’t need it anymore, you must remove it from the list. Make sure that you remove the object from the list before you destroy it – the order is important. Otherwise, the pointers in the elements of the intrusive container might refer to a memory location that no longer contains an object of type <code class="classname">animal</code>.</p><p>Because intrusive containers neither allocate nor free memory, objects stored in an intrusive container continue to exist when the intrusive container is destroyed.</p><p>Since removing elements from intrusive containers doesn’t automatically destroy them, the containers provide non-standard extensions. <code class="methodname">pop_back_and_dispose()</code> is one such member function.</p>
    
    <div class="example" id="ex.intrusive_03"><div class="example-title">Example 18.3. Removing and destroying with <code class="methodname">pop_back_and_dispose()</code></div><div class="example-contents"><pre class="programlisting"><code class="cpp">#include &lt;boost/intrusive/list.hpp&gt;
#include &lt;string&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;

using namespace boost::intrusive;

struct animal : public list_base_hook&lt;&gt;
{
  std::string name;
  int legs;
  animal(std::string n, int l) : name{std::move(n)}, legs{l} {}
};

int main()
{
  animal a1{"cat", 4};
  animal a2{"shark", 0};
  animal *a3 = new animal{"spider", 8};

  typedef list&lt;animal&gt; animal_list;
  animal_list animals;

  animals.push_back(a1);
  animals.push_back(a2);
  animals.push_back(*a3);

  animals.pop_back_and_dispose([](animal *a){ delete a; });

  for (const animal &amp;a : animals)
    std::cout &lt;&lt; a.name &lt;&lt; '\n';
}</code></pre></div></div>
    
  <p><code class="methodname">pop_back_and_dispose()</code> removes an element from a list and destroys it. Because intrusive containers don’t know how an element should be destroyed, you need to pass to <code class="methodname">pop_back_and_dispose()</code> a function or function object that does know how to destroy the element. <code class="methodname">pop_back_and_dispose()</code> will remove the object from the list, then call the function or function object and pass it a pointer to the object to be destroyed. <a class="xref" href="boost.intrusive#ex.intrusive_03" title="Example 18.3. Removing and destroying with pop_back_and_dispose()">Example 18.3</a> passes a lambda function that calls <code class="code">delete</code>.</p><p>In <a class="xref" href="boost.intrusive#ex.intrusive_03" title="Example 18.3. Removing and destroying with pop_back_and_dispose()">Example 18.3</a>, only the third element in <var class="varname">animals</var> can be removed with <code class="methodname">pop_back_and_dispose()</code>. The other elements in the list haven’t been created with <code class="code">new</code> and, thus, must not be destroyed with <code class="code">delete</code>.</p><p>Boost.Intrusive supports another mechanism to link removing and destroying of elements.</p>
    
    <div class="example" id="ex.intrusive_04"><div class="example-title">Example 18.4. Removing and destroying with auto unlink mode</div><div class="example-contents"><pre class="programlisting"><code class="cpp">#include &lt;boost/intrusive/list.hpp&gt;
#include &lt;string&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;

using namespace boost::intrusive;

typedef link_mode&lt;auto_unlink&gt; mode;

struct animal : public list_base_hook&lt;mode&gt;
{
  std::string name;
  int legs;
  animal(std::string n, int l) : name{std::move(n)}, legs{l} {}
};

int main()
{
  animal a1{"cat", 4};
  animal a2{"shark", 0};
  animal *a3 = new animal{"spider", 8};

  typedef constant_time_size&lt;false&gt; constant_time_size;
  typedef list&lt;animal, constant_time_size&gt; animal_list;
  animal_list animals;

  animals.push_back(a1);
  animals.push_back(a2);
  animals.push_back(*a3);

  delete a3;

  for (const animal &amp;a : animals)
    std::cout &lt;&lt; a.name &lt;&lt; '\n';
}</code></pre></div></div>
    
  <p>Hooks support a parameter to set a link mode. The link mode is set with the class template <code class="classname">boost::intrusive::link_mode</code>. If <code class="classname">boost::intrusive::auto_unlink</code> is passed as a template parameter, the auto unlink mode is selected.</p><p>The auto unlink mode automatically removes an element from an intrusive container when it is destroyed. <a class="xref" href="boost.intrusive#ex.intrusive_04" title="Example 18.4. Removing and destroying with auto unlink mode">Example 18.4</a> writes only <code class="computeroutput">cat</code> and <code class="computeroutput">shark</code> to standard output.</p><p>The auto unlink mode can only be used if the member function <code class="methodname">size()</code>, which is provided by all intrusive containers, has no <span class="concept">constant complexity</span>. By default, it has constant complexity, which means: the time it takes for <code class="methodname">size()</code> to return the number of elements doesn’t depend on how many elements are stored in a container. Switching constant complexity on or off is another option to optimize performance.</p><p>To change the complexity of <code class="methodname">size()</code>, use the class template <code class="classname">boost::intrusive::constant_time_size</code>, which expects either <code class="literal">true</code> or <code class="literal">false</code> as a template parameter. <code class="classname">boost::intrusive::constant_time_size</code> can be passed as a second template parameter to intrusive containers, such as <code class="classname">boost::intrusive::list</code>, to set the complexity for <code class="methodname">size()</code>.</p><p>Now that we’ve seen that intrusive containers support link mode and that there is an option to set the complexity for <code class="methodname">size()</code>, it might seem as though there is still much more to discover, but there actually isn’t. There are, for example, only three link modes supported, and auto unlink mode is the only one you need to know. The default mode used if you don’t pick a link mode is good enough for all other use cases.</p><p>Furthermore, there are no options for other member functions. There are no other classes, other than <code class="classname">boost::intrusive::constant_time_size</code>, that you need to learn about.</p><p><a class="xref" href="boost.intrusive#ex.intrusive_05" title="Example 18.5. Defining a hook for boost::intrusive::set as a member variable">Example 18.5</a> introduces a hook mechanism using another intrusive container: <code class="classname">boost::intrusive::set</code>.</p>
    
    <div class="example" id="ex.intrusive_05"><div class="example-title">Example 18.5. Defining a hook for <code class="classname">boost::intrusive::set</code> as a member variable</div><div class="example-contents"><pre class="programlisting"><code class="cpp">#include &lt;boost/intrusive/set.hpp&gt;
#include &lt;string&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;

using namespace boost::intrusive;

struct animal
{
  std::string name;
  int legs;
  set_member_hook&lt;&gt; set_hook;
  animal(std::string n, int l) : name{std::move(n)}, legs{l} {}
  bool operator&lt;(const animal &amp;a) const { return legs &lt; a.legs; }
};

int main()
{
  animal a1{"cat", 4};
  animal a2{"shark", 0};
  animal a3{"spider", 8};

  typedef member_hook&lt;animal, set_member_hook&lt;&gt;, &amp;animal::set_hook&gt; hook;
  typedef set&lt;animal, hook&gt; animal_set;
  animal_set animals;

  animals.insert(a1);
  animals.insert(a2);
  animals.insert(a3);

  for (const animal &amp;a : animals)
    std::cout &lt;&lt; a.name &lt;&lt; '\n';
}</code></pre></div></div>
    
  <p>There are two ways to add a hook to a class: either derive the class from a hook or define the hook as a member variable. While the previous examples derived a class from <code class="classname">boost::intrusive::list_base_hook</code>, <a class="xref" href="boost.intrusive#ex.intrusive_05" title="Example 18.5. Defining a hook for boost::intrusive::set as a member variable">Example 18.5</a> uses the class <code class="classname">boost::intrusive::set_member_hook</code> to define a member variable.</p><p>Please note that the name of the member variable doesn’t matter. However, the hook class you use depends on the intrusive container. For example, to define a hook as a member variable for an intrusive list, use <code class="classname">boost::intrusive::list_member_hook</code> instead of <code class="classname">boost::intrusive::set_member_hook</code>.</p><p>Intrusive containers have different hooks because they have different requirements for elements. However, you can use different several hooks to allow objects to be stored in multiple intrusive containers. <code class="classname">boost::intrusive::any_base_hook</code> and <code class="classname">boost::intrusive::any_member_hook</code> let you store objects in any intrusive container. Thanks to these classes, you don’t need to derive from multiple hooks or define multiple member variables as hooks.</p><p>Intrusive containers expect hooks to be defined in base classes by default. If a member variable is used as a hook, as in <a class="xref" href="boost.intrusive#ex.intrusive_05" title="Example 18.5. Defining a hook for boost::intrusive::set as a member variable">Example 18.5</a>, the intrusive container has to be told which member variable to use. That’s why both <code class="classname">animal</code> and the type <code class="type">hook</code> are passed to <code class="classname">boost::intrusive::set</code>. <code class="type">hook</code> is defined with <code class="classname">boost::intrusive::member_hook</code>, which is used whenever a member variable serves as a hook. <code class="classname">boost::intrusive::member_hook</code> expects the element type, the type of the hook, and a pointer to the member variable as template parameters.</p><p><a class="xref" href="boost.intrusive#ex.intrusive_05" title="Example 18.5. Defining a hook for boost::intrusive::set as a member variable">Example 18.5</a> writes <code class="computeroutput">shark</code>, <code class="computeroutput">cat</code>, and <code class="computeroutput">spider</code>, in that order, to standard output.</p><p>In addition to the classes <code class="classname">boost::intrusive::list</code> and <code class="classname">boost::intrusive::set</code> introduced in this chapter, Boost.Intrusive also provides, for example, <code class="classname">boost::intrusive::slist</code> for singly linked lists and <code class="classname">boost::intrusive::unordered_set</code> for hash containers.</p></div><div><div class="prev"><a href="boost.heap">Prev</a></div><div class="next"><a href="boost.multiarray">Next</a></div></div>
    <div id="disqus_thread"></div>
<script>
  var disqus_shortname = 'theboostcpplibraries';
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<a href="https://github.com/BorisSchaeling/theboostcpplibraries" class="github-corner" aria-label="View source on Github" onclick="ga('send', 'event', 'github', 'click', 'view');return true;"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#ddd; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

  </body></html>
